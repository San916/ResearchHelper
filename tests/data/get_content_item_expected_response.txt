{"original_post":{"content_body":"<p>Building on what I learned here: <a href=\"https://stackoverflow.com/questions/13746067/manipulating-dynamic-array-through-functions-in-c\">Manipulating dynamic array through functions in C</a>.</p>\n\n<pre><code>void test(int data[])\n{\n    data[0] = 1;    \n}    \n\nint main(void)\n{    \n    int *data = malloc(4 * sizeof *data);\n\n    test(data);\n\n    return 0;\n}\n</code></pre>\n\n<p>This works fine. However, I am also trying to using <code>realloc</code> in a function.</p>\n\n<pre><code>void increase(int data[])\n{\n    data = realloc(data, 5 * sizeof *data);    \n}\n</code></pre>\n\n<p>This complies but the program crashes when run.</p>\n\n<p><strong>Question</strong> </p>\n\n<p>How should I be using realloc in a function?</p>\n\n<p>I understand that I should assign the result of <code>realloc</code> to a variable and check if it is <code>NULL</code> first. This is just a simplified example.</p>\n","score":0},"comments":[{"content_body":"<p>You want to modify the value of an <code>int*</code> (your array) so need to pass a pointer to it into your <code>increase</code> function:</p>\n\n<pre><code>void increase(int** data)\n{\n    *data = realloc(*data, 5 * sizeof int);\n}\n</code></pre>\n\n<p>Calling code would then look like:</p>\n\n<pre><code>int *data = malloc(4 * sizeof *data);\n/* do stuff with data */\nincrease(&amp;data);\n/* more stuff */\nfree(data);\n</code></pre>\n","score":41},{"content_body":"<p>Keep in mind the difference between a pointer and an array.<br>\nAn array is a chuck of memory in the stack, and that's all.If you have an array:  </p>\n\n<pre><code>int arr[100];\n</code></pre>\n\n<p>Then arr is an address of memory, but also &amp;arr is an adress of memory, and that address of memory is constant, not stored in any location.So you cannot say arr=NULL, since arr is not a variable that points to something.It's just a symbolic address: the address of where the array starts.Instead a pointer has it's own memory and can point to memory addresses.  </p>\n\n<p>It's enough that you change int[] to int*.<br>\nAlso, variables are passed by copy so you need to pass an int** to the function.  </p>\n\n<p>About how using realloc, all the didactic examples include this:  </p>\n\n<ol>\n<li>Use realloc;  </li>\n<li>Check if it's NULL.In this case use perror and exit the program;  </li>\n<li>If it's not NULL use the memory allocated;  </li>\n<li>Free the memory when you don't need it anymore.</li>\n</ol>\n\n<p>So that would be a nice example:  </p>\n\n<pre><code>int* chuck= (int*) realloc (NULL, 10*sizeof(int)); // Acts like malloc,\n              // casting is optional but I'd suggest it for readability\nassert(chuck);\nfor(unsigned int i=0; i&lt;10; i++)\n{\n    chunk[i]=i*10;\n    printf(\"%d\",chunk[i]);\n}\nfree(chunk);\n</code></pre>\n","score":8},{"content_body":"<p>Both code are very problematic, if you use the same pointer to send and receive from realloc, if it fails, you will lose your pointer to free it later.</p>\n\n<p>you should do some thing like this :</p>\n\n<p>{\n...\n...   </p>\n\n<pre><code>more = realloc(area , size);\nif( more == NULL )\n    free(area);\nelse\n    area=more;\n</code></pre>\n\n<p>...\n...</p>\n\n<p>}</p>\n","score":6}],"comment_count":3}